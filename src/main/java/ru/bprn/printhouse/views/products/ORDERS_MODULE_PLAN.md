# План разработки модуля "Оформление заказов"

Этот документ является "рыбой" для проектирования и разработки нового модуля.

## Концепция

Модуль позволит клиентам (или менеджерам) на основе существующих шаблонов (`Templates`) конфигурировать конкретный заказ (выбирать тираж, материалы, изменять доступные параметры), видеть итоговую стоимость и размещать заказ в системе.

---

## Этап 1: Проектирование модели данных

Новые сущности для хранения информации о заказах. Важно "отвязать" созданный заказ от шаблона, скопировав все данные на момент создания. Это гарантирует, что редактирование шаблона в будущем не повлияет на уже оформленные заказы.

1.  **`CustomerOrder` (Заказ клиента)**
    *   `id`: `UUID`
    *   `orderNumber`: `String` — Уникальный номер заказа (напр., "2024-10-01").
    *   `customer`: `User` — Ссылка на зарегистрированного пользователя-заказчика (может быть `null` для гостевых заказов).
    *   `customerName`: `String` — Имя клиента (для гостей или для уточнения).
    *   `customerContacts`: `String` — Контактные данные (email, телефон).
    *   `isLegalEntity`: `boolean` — Флаг, указывающий, является ли клиент юрлицом.
    *   `companyDetails`: `String` (JSON/TEXT) — Реквизиты компании, если это юрлицо.
    *   `status`: `OrderStatus` (enum) — Статус заказа: `DRAFT` (Черновик), `PENDING_PAYMENT` (Ожидает оплаты), `IN_PROGRESS` (В работе), `COMPLETED` (Выполнен), `CANCELLED` (Отменен).
    *   `totalPrice`: `int` — Итоговая стоимость всего заказа.
    *   `items`: `List<OrderItem>` — Список позиций в заказе (связь One-to-Many).
    *   `createdAt`, `updatedAt`: `LocalDateTime`.

2.  **`OrderItem` (Позиция в заказе)**
    *   `id`: `UUID`
    *   `customerOrder`: `CustomerOrder` — Ссылка на родительский заказ.
    *   `sourceProductTypeId`: `UUID` — ID шаблона `Templates`, на основе которого создана позиция.
    *   `name`: `String` — Наименование позиции (напр., "Визитка 90х50, мелованная бумага, 1000 шт").
    *   `quantity`: `Integer` — Тираж.
    *   `price`: `int` — Итоговая цена за эту позицию в минимальных денежных единицах(за весь тираж).
    *   `priceForOne` : `int` — Цена за одну единицу продукта`.
    *   `configuration`: `String` (JSON) — **Ключевое поле**. Сериализованный в JSON объект, который "замораживает" всю конфигурацию продукта на момент заказа. Он будет хранить копию всех операций и их переменных.

3.  **`OrderItemConfiguration` (Конфигурация позиции заказа)** - это не сущность, а структура для хранения в JSON-поле `OrderItem.configuration`.
    *   `productName`: `String`
    *   `sizeX`, `sizeY`, `bleed`: `Double`
    *   `selectedMainMaterialId`: `UUID` — ID выбранного основного материала (например, бумаги).
    *   `abstractProductType`: `List<ConfiguredAbstractProductType>`
    *   `operations`: `List<ConfiguredOperation>`

    **`ConfiguredAbstractProductType` (Структура для сконфигурированного типа продукта)**
    *   `sourceAbstractProductTypeId`: `UUID` — ID исходного `AbstractProductType` из шаблона.
    *   `name`: `String` — Имя компонента (например, "Обложка" или "Внутренний блок").
    *   `sizeX`, `sizeY`, `bleed`: `Double` — Размеры и вылеты, если применимо.
    *   `selectedMainMaterialId`: `UUID` — ID выбранного основного материала для этого компонента.
    *   `variables`: `List<ConfiguredVariable>` — Список измененных пользователем переменных, относящихся к этому компоненту.
    *   `operations`: `List<ConfiguredOperation>` — Список сконфигурированных операций для этого компонента.

4.  **`ConfiguredOperation` (Структура для сконфигурированной операции)**
    *   `productOperationId`: `UUID` — ID исходной `ProductOperation` из шаблона.
    *   `name`: `String`
    *   `isSwitchedOff`: `boolean`
    *   `selectedMaterialId`: `UUID` — ID выбранного материала для данной операции (например, краски).
    *   `cost`: `BigDecimal` (рассчитанная стоимость этой операции)
    *   `variables`: `List<ConfiguredVariable>` — Список **измененных пользователем** переменных.

5.  **`ConfiguredVariable` (Структура для сконфигурированной переменной)**
    *   `key`, `value`, `description`: `String`

---

## Этап 2: Пользовательский интерфейс (UI)

Предлагается реализовать классический путь пользователя: `Каталог -> Конфигуратор -> Корзина -> Оформление`.

1.  **`ProductCatalogView` (Каталог продукции)**
    *   **Что делает**: Заменяет старый `ProductsView`. Отображает все доступные для заказа продукты (`AbstractProductType`) в виде карточек.
    *   **Группировка**: Карточки можно сгруппировать по родительским `Templates` (например, секции "Визитки", "Листовки").
    *   **Поиск и фильтрация**: Сверху страницы — поле для полнотекстового поиска. Сбоку — панель с фильтрами (фасетами) по категориям, размерам, типам материалов.
    *   **Элементы (Карточка продукта)**:
        *   Изображение, название, краткое описание.
        *   **Блок быстрого заказа**:
            *   Поле для ввода тиража (значение по умолчанию из `Templates.quantity`).
            *   Кнопка "В корзину" для добавления товара с конфигурацией по умолчанию.
        *   Кнопка "Настроить", которая открывает `ProductConfiguratorDialog`.

2.  **`ProductConfiguratorDialog` (Диалог конфигурации продукта)**
    *   **Что делает**: Модальное окно, которое открывается по клику на "Настроить и заказать".
    *   **Входные данные**: Принимает ID `AbstractProductType`.
    *   **Поля для пользователя**:
        *   Поле для ввода **тиража** (`quantity`).
        *   Выпадающий список для выбора **основного материала** (бумаги) из тех, что доступны в `AbstractProductType`.
        *   Для каждой настраиваемой операции (`ProductOperation`):
            *   Чекбокс "Включить/Отключить", если `switchOffAllowed = true`.
            *   Выпадающий список для выбора **материала операции** (например, цветности печати), если у операции есть доступные материалы.
            *   Поля для редактирования **переменных**, которые помечены как видимые (`show = true`).
    *   **Интерактивность**: Внизу диалога отображается цена, которая пересчитывается в реальном времени при изменении любого параметра.
    *   **Действие**: Кнопка "Добавить в корзину".

3.  **`ShoppingCartView` (Корзина)**
    *   **Что делает**: Стандартная корзина, доступная, например, по иконке в `MainLayout`.
    *   **Функционал**: Показывает список добавленных `OrderItem`, позволяет менять их количество или удалять. Отображает общую стоимость заказа.
    *   **Действие**: Кнопка "Оформить заказ", которая ведет на `CheckoutView`.

4.  **`CheckoutView` и `OrderHistoryView`**
    *   На последующих этапах: страницы для ввода данных клиента, выбора доставки/оплаты и просмотра истории своих заказов.

---

## Этап 3: Сервисный слой и бизнес-логика

1.  **`PriceCalculationService` (Сервис расчета цены)**
    *   **Основной метод**: `calculatePrice(AbstractProductType product, int quantity, Map<String, Object> userVariables)`
    *   **Логика работы**:
        1.  Итерирует по списку `product.getProductOperations()`.
        2.  Для каждой операции, если она не отключена, выполняет ее формулы (`customMachineTimeFormula`, `customActionFormula`, `customMaterialFormula`).
        3.  Для выполнения формул используется скриптовый движок (у вас уже есть наработки в `FormulaEditor`), в контекст которого передаются:
            *   `quantity` (тираж).
            *   Переменные самого продукта (размеры и т.д.).
            *   Все `customVariables` из операции, переопределенные пользовательскими значениями из `userVariables`.
        4.  Результат (время, расход материала) умножается на стоимость (цена часа работы станка, цена материала и т.д. — их нужно будет где-то хранить, например, в `AbstractMachine` и `AbstractMaterials`).
        5.  Стоимости всех операций суммируются, формируя итоговую цену `OrderItem`.

2.  **`OrderService` (Сервис управления заказами)**
    *   `addItemToCart(productTypeId, quantity, userVariables)`: Создает `OrderItem`, вызывает `PriceCalculationService`, сериализует конфигурацию в JSON и сохраняет позицию в "корзине" (которая может быть временным `CustomerOrder` в статусе `DRAFT`).
    *   `placeOrder(CustomerOrder order)`: Финализирует заказ, меняет его статус и сохраняет в БД.
    *   `getOrdersForUser(User user)`: Возвращает историю заказов для пользователя.

---

## Предложение по реализации

Я могу помочь с реализацией первого и самого важного шага — **созданием `ProductCatalogView` и `ProductConfiguratorDialog`**. Это позволит вам "оживить" созданные шаблоны и увидеть, как работает логика расчета.