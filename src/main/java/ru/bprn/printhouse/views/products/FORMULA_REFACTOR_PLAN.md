# План рефакторинга системы формул и расчетов

Этот документ описывает план по переработке механизма хранения и выполнения формул для создания гибкого и расширяемого движка расчетов.

## 1. Цель

Создать универсальный сервис расчета (`PriceCalculationService`), который не содержит жестко закодированной последовательности вычислений, а вместо этого динамически собирает и выполняет формулы в заданном порядке. Это позволит легко добавлять новые этапы расчета и изменять их логику, не переписывая основной сервис.

## 2. Проблема текущего подхода

*   **Смешение данных и логики:** Формулы хранятся как обычные `Variable` (`"machineTimeFormula" -> "expression"`), что смешивает данные (параметры) и логику (код) в одной коллекции.
*   **Отсутствие порядка:** Невозможно гарантировать порядок выполнения формул, что критически важно для зависимых вычислений (например, `finalSheets` должен быть рассчитан до `machineTime`).
*   **"Костыли" в UI:** Редакторы (`MapEditorView`, `ProductOperationEditor`) вынуждены вручную фильтровать переменные по имени (`.contains("Formula")`), чтобы не показывать код пользователю.

## 3. План рефакторинга (To-Do)

### Шаг 1: Обновление модели данных

1.  **Создать `enum CalculationPhase`**:
    *   Определить основные этапы расчета, например: `PREPARATION` (подготовка), `WASTE_CALCULATION` (расчет брака), `TECHNICAL_CALCULATION` (расчет времени/материалов), `ECONOMIC_CALCULATION` (расчет стоимости).

2.  **Создать класс `Formula`**:
    *   Это будет не JPA-сущность, а встраиваемый класс для хранения в JSON.
    *   **Поля:**
        *   `key` (String): Имя переменной, которую вычисляет формула (например, `machineTime`).
        *   `expression` (String): Groovy-выражение.
        *   `phase` (CalculationPhase): Фаза расчета, к которой относится формула.
        *   `priority` (int): Приоритет выполнения внутри одной фазы (чем меньше, тем раньше).

3.  **Обновить сущности иерархии `Templates`**:
    *   В классах `Templates`, `AbstractProductType`, `Operation`, `ProductOperation` заменить хранение формул в `List<Variable>` на новое поле: `private List<Formula> formulas = new ArrayList<>();`.
    *   Поле должно быть аннотировано `@JdbcTypeCode(SqlTypes.JSON)`.

### Шаг 2: Адаптация сервисов

1.  **Обновить сервисы инициализации (`...VariableService`)**:
    *   В `TemplateVariableService`, `ProductTypeVariableService`, `OperationVariableService` разделить логику:
        *   Создание обычных переменных (`new Variable(...)`) остается.
        *   Вместо создания "переменных-формул" (`new Variable("machineTimeFormula", ...)`), создавать объекты `new Formula("machineTime", "...", CalculationPhase.TECHNICAL_CALCULATION, 10)`.

2.  **Спроектировать новый `PriceCalculationService`**:
    *   **Метод `calculate(...)`**:
        1.  **Сбор контекста:** Рекурсивно обходит иерархию (`Templates` -> `ProductType` -> `ProductOperation` -> `Operation` -> `Machine`) и собирает все `List<Variable>` в один `Map<String, Object> context`.
        2.  **Сбор и сортировка формул:** Так же рекурсивно собирает все `List<Formula>` в один общий список. Сортирует этот список сначала по `phase` (по порядку `enum`), затем по `priority`.
        3.  **Поэтапное выполнение:** Итерирует по отсортированному списку формул, выполняет каждую с помощью `GroovyShell` и добавляет результат обратно в `context`, делая его доступным для следующих формул.

### Шаг 3: Рефакторинг UI (Редакторы)

1.  **Упростить `MapEditorView`**:
    *   Удалить метод `isFormulaVariable()` и всю логику фильтрации. Теперь этот компонент будет отвечать только за редактирование `List<Variable>`.

2.  **Обновить редакторы (`OperationEditor`, `OneSheetDigitalPrintingProductTypeEditor` и др.)**:
    *   Удалить старые `EditableTextArea`, которые были привязаны к переменным-формулам.
    *   Добавить новые `EditableTextArea` (или другие компоненты), которые будут напрямую работать с объектами из `List<Formula>`.
    *   Например, в `OperationEditor` будет 5 полей для редактирования формул, каждое из которых будет находить в `List<Formula>` объект по ключу (`machineTime`, `actionTime` и т.д.) и редактировать его поле `expression`.

3.  **Интегрировать справочник `Formulas`**:
    *   В `EditableTextArea` или рядом с ним добавить кнопку "Выбрать из справочника", которая будет открывать `FormulaDialog` и вставлять выбранное выражение в поле.